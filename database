import cv2
import os
import sqlite3
import folium
from ultralytics import YOLO
import websocket
import json
import numpy as np
import threading
import math
from datetime import datetime

# Initialize database
DB_FILE = "potholes.db"
def init_db():
    conn = sqlite3.connect(DB_FILE)
    cursor = conn.cursor()
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS potholes (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            latitude REAL,
            longitude REAL,
            severity TEXT,
            timestamp TEXT
        )
    ''')
    conn.commit()
    conn.close()
init_db()

def save_pothole_to_db(lat, lon, severity):
    conn = sqlite3.connect(DB_FILE)
    cursor = conn.cursor()
    cursor.execute("SELECT * FROM potholes WHERE latitude=? AND longitude=?", (lat, lon))
    if cursor.fetchone() is None:
        cursor.execute("INSERT INTO potholes (latitude, longitude, severity, timestamp) VALUES (?, ?, ?, ?)", 
                       (lat, lon, severity, datetime.now().isoformat()))
        conn.commit()
    conn.close()

def generate_pothole_map():
    conn = sqlite3.connect(DB_FILE)
    cursor = conn.cursor()
    cursor.execute("SELECT latitude, longitude, severity FROM potholes")
    potholes = cursor.fetchall()
    conn.close()
    
    pothole_map = folium.Map(location=[12.9716, 77.5946], zoom_start=12)
    severity_colors = {"Low": "green", "Moderate": "orange", "High": "red"}
    for lat, lon, severity in potholes:
        folium.Marker([lat, lon], popup=f"Severity: {severity}", 
                      icon=folium.Icon(color=severity_colors.get(severity, "blue"))).add_to(pothole_map)
    pothole_map.save("potholes_map.html")

def process_frame():
    while True:
        ret, frame = cap.read()
        if not ret:
            print("Error: Failed to capture frame")
            break
        results = model.predict(frame, conf=0.6, iou=0.4)
        annotated_frame = frame.copy()
        lat, lon = parse_gps_data(gps_data)
        if lat and lon:
            cv2.putText(annotated_frame, f"GPS: ({lat:.6f}, {lon:.6f})", (10, 30), cv2.FONT_HERSHEY_SIMPLEX, 1.0, (255, 255, 255), 3)
        if results[0].masks is not None and len(results[0].masks.data) > 0:
            for mask in results[0].masks.data:
                mask_np = mask.cpu().numpy().astype(np.uint8)
                if mask_np.size == 0:
                    continue
                mask_resized = cv2.resize(mask_np, (frame.shape[1], frame.shape[0]))
                pixels_area = cv2.countNonZero(mask_resized)
                distance_m = REFERENCE_DISTANCE
                real_area_cm2 = estimate_real_area(pixels_area, distance_m)
                severity, color = calculate_severity(real_area_cm2)
                x, y, w, h = cv2.boundingRect(mask_resized)
                angle = math.atan2(y + h / 2 - frame.shape[0] / 2, x + w / 2 - frame.shape[1] / 2)
                pothole_lat, pothole_lon = adjust_gps_coordinates(lat, lon, distance_m, angle)
                cv2.rectangle(annotated_frame, (x, y), (x + w, y + h), color, 2)
                cv2.putText(annotated_frame, f"Severity: {severity} ({real_area_cm2:.1f} cm^2)", (x, y - 10), cv2.FONT_HERSHEY_SIMPLEX, 1.0, color, 3)
                cv2.putText(annotated_frame, f"Location: ({pothole_lat:.6f}, {pothole_lon:.6f})", (x, y + h + 20), cv2.FONT_HERSHEY_SIMPLEX, 1.0, color, 3)
                if not is_pothole_detected(pothole_lat, pothole_lon):
                    detected_potholes.append({'lat': pothole_lat, 'lon': pothole_lon, 'severity': severity})
                    save_pothole_to_db(pothole_lat, pothole_lon, severity)
                    generate_pothole_map()
                mask_colored = np.zeros_like(frame)
                mask_colored[mask_resized > 0] = color
                annotated_frame = cv2.addWeighted(annotated_frame, 1, mask_colored, 0.5, 0)
        cv2.imshow("Pothole Detection", cv2.resize(annotated_frame, (640, 480)))
        if cv2.waitKey(1) & 0xFF == ord("q"):
            break
    cap.release()
    cv2.destroyAllWindows()
