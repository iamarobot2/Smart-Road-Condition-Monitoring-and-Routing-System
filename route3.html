<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Pothole-Aware Routing</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css"/>
  <link rel="stylesheet" href="https://unpkg.com/leaflet-routing-machine@3.2.12/dist/leaflet-routing-machine.css" />
  <style>
    body {
      margin: 0;
      font-family: Arial, sans-serif;
      background-color: #f4f4f4;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    h1 {
      margin: 10px 0;
      font-size: 24px;
      color: #333;
      text-align: center;
    }
    #map {
      width: 90%;
      height: 80vh;
      border-radius: 10px;
      box-shadow: 0px 4px 10px rgba(0, 0, 0, 0.1);
    }
    .legend {
      background: white;
      padding: 10px;
      border-radius: 5px;
      box-shadow: 0px 2px 5px rgba(0, 0, 0, 0.2);
      margin-top: 10px;
      text-align: left;
      display: flex;
      gap: 20px;
    }
    .legend span {
      display: inline-block;
      width: 12px;
      height: 12px;
      margin-right: 5px;
      border-radius: 50%;
    }
    .controls {
      margin: 10px;
      display: flex;
      gap: 10px;
    }
    .controls input {
      padding: 5px;
      font-size: 14px;
    }
    .controls button {
      padding: 5px 10px;
      font-size: 14px;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <h1>Pothole-Aware Routing</h1>
  <div class="controls">
    <input type="text" id="source" placeholder="Source (lat,lng)">
    <input type="text" id="destination" placeholder="Destination (lat,lng)">
    <button onclick="createRoute()">Get Optimal Route</button>
  </div>
  <div id="map"></div>
  <div class="legend">
    <p><span style="background: green;"></span> Low Severity</p>
    <p><span style="background: orange;"></span> Moderate Severity</p>
    <p><span style="background: red;"></span> High Severity</p>
  </div>

  <script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>
  <script src="https://unpkg.com/leaflet-routing-machine@3.2.12/dist/leaflet-routing-machine.js"></script>
  <script>
    // Configuration
    const MAPBOX_TOKEN = 'pk.eyJ1IjoiZ290bWFqaSIsImEiOiJjbTk2MnV4ZWIwcXYzMmtzamxsb2JtZDBrIn0.lmTR_LMzgdQbQoL9E0FaUw'; // *************************************************Replace with your actual token
    const POTHOLE_DETECTION_RADIUS = 50; // meters
    let map, routingControl, potholes = [];
    let sourceMarker, destinationMarker, optimalRouteLayer;

    // Initialize Map
    function initMap() {
      map = L.map('map').setView([9.52853, 76.82520], 15);
      L.tileLayer(`https://api.mapbox.com/styles/v1/mapbox/streets-v11/tiles/{z}/{x}/{y}?access_token=${MAPBOX_TOKEN}`, {
        attribution: '© Mapbox contributors'
      }).addTo(map);
    }

    // Custom black icons for markers
    const blackIcon = new L.Icon({
      iconUrl: 'https://cdn.rawgit.com/pointhi/leaflet-color-markers/master/img/marker-icon-black.png',
      shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
      iconSize: [25, 41],
      iconAnchor: [12, 41],
      popupAnchor: [1, -34],
      shadowSize: [41, 41]
    });

    // Fetch potholes from backend
    async function fetchPotholes() {
      try {
        const response = await fetch('http://localhost:5000/kuzhi');
        potholes = await response.json();
        updatePotholeMarkers();
      } catch (error) {
        console.error('Error fetching potholes:', error);
      }
    }

    // Update pothole markers on map
    function updatePotholeMarkers() {
      // Clear existing pothole markers
      map.eachLayer(layer => {
        if (layer instanceof L.CircleMarker) map.removeLayer(layer);
      });

      // Add new markers
      potholes.forEach(pothole => {
        if (!pothole.latitude || !pothole.longitude) return;
        
        const color = {
          'Low': 'green',
          'Moderate': 'orange',
          'High': 'red'
        }[pothole.severity] || 'gray';
        
        L.circleMarker([pothole.latitude, pothole.longitude], {
          color: color,
          radius: 8,
          fillOpacity: 0.8
        }).addTo(map).bindPopup(`Severity: ${pothole.severity}`);
      });
    }

    // Main route creation function
    async function createRoute() {
      const sourceVal = document.getElementById("source").value.trim();
      const destVal = document.getElementById("destination").value.trim();
      
      if (!sourceVal || !destVal) {
        alert("Please enter both source and destination coordinates.");
        return;
      }

      const [srcLat, srcLng] = sourceVal.split(',').map(Number);
      const [dstLat, dstLng] = destVal.split(',').map(Number);

      // Clear previous route and markers
      clearMapElements();

      // Add new markers
      sourceMarker = L.marker([srcLat, srcLng], {icon: blackIcon})
        .addTo(map)
        .bindPopup("Source");
      destinationMarker = L.marker([dstLat, dstLng], {icon: blackIcon})
        .addTo(map)
        .bindPopup("Destination");

      // Get and evaluate routes
      const routes = await fetchMapboxRoutes(srcLat, srcLng, dstLat, dstLng);
      if (!routes || routes.length === 0) {
        alert("No routes found!");
        return;
      }

      // Find and display optimal route
      const optimalRoute = findOptimalRoute(routes);
      displayOptimalRoute(optimalRoute, srcLat, srcLng, dstLat, dstLng);
    }

    // Fetch routes from Mapbox
    async function fetchMapboxRoutes(srcLat, srcLng, dstLat, dstLng) {
      try {
        const response = await fetch(
          `https://api.mapbox.com/directions/v5/mapbox/driving/${srcLng},${srcLat};${dstLng},${dstLat}?` +
          `alternatives=true&geometries=geojson&access_token=${MAPBOX_TOKEN}`
        );
        const data = await response.json();
        return data.routes;
      } catch (error) {
        console.error("Error fetching routes:", error);
        return null;
      }
    }

    // Find route with lowest pothole weight
    function findOptimalRoute(routes) {
      let optimalRoute = null;
      let lowestWeight = Infinity;

      routes.forEach(route => {
        const coordinates = route.geometry.coordinates.map(coord => [coord[1], coord[0]]);
        const weight = calculatePotholeWeight(coordinates);
        
        console.log(`Route ${routes.indexOf(route)} - Weight: ${weight}, Distance: ${(route.distance/1000).toFixed(2)}km`);
        
        if (weight < lowestWeight) {
          lowestWeight = weight;
          optimalRoute = route;
        }
      });

      console.log("Selected route with weight:", lowestWeight);
      return optimalRoute;
    }

    // Calculate pothole weight for a route
    function calculatePotholeWeight(coordinates) {
      let totalWeight = 0;
      const step = Math.max(1, Math.floor(coordinates.length / 50)); // Sample points for performance

      for (let i = 0; i < coordinates.length; i += step) {
        const coord = coordinates[i];
        potholes.forEach(pothole => {
          const dist = calculateDistance(coord, [pothole.latitude, pothole.longitude]);
          if (dist < POTHOLE_DETECTION_RADIUS) {
            totalWeight += getSeverityWeight(pothole.severity) * (1 - dist/POTHOLE_DETECTION_RADIUS);
          }
        });
      }
      return totalWeight;
    }

    // Display the optimal route
    function displayOptimalRoute(route, srcLat, srcLng, dstLat, dstLng) {
      // Remove previous routing control
      if (routingControl) map.removeControl(routingControl);
      if (optimalRouteLayer) map.removeLayer(optimalRouteLayer);

      // Add new route
      optimalRouteLayer = L.geoJSON(route.geometry, {
        style: { color: '#0066ff', weight: 6, opacity: 0.8 }
      }).addTo(map);

      // Initialize routing control with Mapbox
      routingControl = L.Routing.control({
        waypoints: [
          L.latLng(srcLat, srcLng),
          L.latLng(dstLat, dstLng)
        ],
        router: L.Routing.mapbox(MAPBOX_TOKEN, {
          profile: 'mapbox/driving',
          alternatives: true
        }),
        routeWhileDragging: false,
        show: false, // Hide default route line
        createMarker: () => null, // No default markers
        lineOptions: { styles: [{ opacity: 0 }] } // Hide duplicate line
      }).addTo(map);

      // Fit bounds to route
      map.fitBounds(optimalRouteLayer.getBounds(), { padding: [50, 50] });
    }

    // Helper functions
    function clearMapElements() {
      if (sourceMarker) map.removeLayer(sourceMarker);
      if (destinationMarker) map.removeLayer(destinationMarker);
      if (optimalRouteLayer) map.removeLayer(optimalRouteLayer);
      if (routingControl) map.removeControl(routingControl);
    }

    function getSeverityWeight(severity) {
      const weights = { 'High': 3, 'Moderate': 2, 'Low': 1 };
      return weights[severity] || 0;
    }

    function calculateDistance(coord1, coord2) {
      const R = 6371e3;
      const φ1 = coord1[0] * Math.PI/180;
      const φ2 = coord2[0] * Math.PI/180;
      const Δφ = (coord2[0] - coord1[0]) * Math.PI/180;
      const Δλ = (coord2[1] - coord1[1]) * Math.PI/180;

      const a = Math.sin(Δφ/2) * Math.sin(Δφ/2) +
                Math.cos(φ1) * Math.cos(φ2) *
                Math.sin(Δλ/2) * Math.sin(Δλ/2);
      return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
    }

    // Initialize
    initMap();
    fetchPotholes();
    setInterval(fetchPotholes, 10000);
  </script>
</body>
</html>