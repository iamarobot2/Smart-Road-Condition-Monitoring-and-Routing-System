import random
import time
import numpy as np

from deap import base, creator, tools
from scipy.stats import norm

# Define problem constants
NUM_ASSETS = 5
TARGET_RETURN = 0.05
RISK_FREE_RATE = 0.01
CXPB = 0.7  # Crossover probability
MUTPB = 0.2  # Mutation probability
MU = 20  # Distribution index for SBX
ETA = 20  # Distribution index for polynomial mutation

# Sample mean returns and covariance matrix for demonstration
mean_returns = np.array([0.03, 0.05, 0.07, 0.06, 0.04])
cov_matrix = np.array([
    [0.1, 0.02, 0.04, 0.03, 0.01],
    [0.02, 0.08, 0.01, 0.02, 0.03],
    [0.04, 0.01, 0.12, 0.03, 0.02],
    [0.03, 0.02, 0.03, 0.09, 0.01],
    [0.01, 0.03, 0.02, 0.01, 0.07],
])

# Define fitness and individual
creator.create("FitnessMax", base.Fitness, weights=(1.0,))
creator.create("Individual", list, fitness=creator.FitnessMax)

toolbox = base.Toolbox()
toolbox.register("attr_float", random.random)
toolbox.register("individual", tools.initRepeat, creator.Individual, toolbox.attr_float, n=NUM_ASSETS)
toolbox.register("population", tools.initRepeat, list, toolbox.individual)

def evaluate(individual):
    weights = np.array(individual)
    weights = weights / np.sum(weights)  # Normalize weights

    port_return = np.dot(weights, mean_returns)
    port_variance = np.dot(weights.T, np.dot(cov_matrix, weights))
    port_stddev = np.sqrt(port_variance)

    sharpe_ratio = (port_return - RISK_FREE_RATE) / port_stddev
    return (sharpe_ratio,)

toolbox.register("evaluate", evaluate)
toolbox.register("select", tools.selTournament, tournsize=3)

def sbx_crossover(ind1, ind2, eta=MU):
    size = min(len(ind1), len(ind2))
    for i in range(size):
        if random.random() <= 0.5:
            if abs(ind1[i] - ind2[i]) > 1e-14:
                x1 = min(ind1[i], ind2[i])
                x2 = max(ind1[i], ind2[i])
                rand = random.random()
                beta = 1.0 + (2.0 * (x1 - 0.0) / (x2 - x1))
                alpha = 2.0 - pow(beta, -(eta + 1.0))
                if rand <= (1.0 / alpha):
                    betaq = pow((rand * alpha), (1.0 / (eta + 1.0)))
                else:
                    betaq = pow((1.0 / (2.0 - rand * alpha)), (1.0 / (eta + 1.0)))
                c1 = 0.5 * ((x1 + x2) - betaq * (x2 - x1))

                beta = 1.0 + (2.0 * (1.0 - x2) / (x2 - x1))
                alpha = 2.0 - pow(beta, -(eta + 1.0))
                if rand <= (1.0 / alpha):
                    betaq = pow((rand * alpha), (1.0 / (eta + 1.0)))
                else:
                    betaq = pow((1.0 / (2.0 - rand * alpha)), (1.0 / (eta + 1.0)))
                c2 = 0.5 * ((x1 + x2) + betaq * (x2 - x1))

                c1 = min(max(c1, 0.0), 1.0)
                c2 = min(max(c2, 0.0), 1.0)

                if random.random() <= 0.5:
                    ind1[i] = c2
                    ind2[i] = c1
                else:
                    ind1[i] = c1
                    ind2[i] = c2
    return ind1, ind2

def polynomial_mutation(individual, eta=ETA, low=0.0, up=1.0, indpb=0.1):
    for i in range(len(individual)):
        if random.random() < indpb:
            x = individual[i]
            delta1 = (x - low) / (up - low)
            delta2 = (up - x) / (up - low)
            rand = random.random()
            mut_pow = 1.0 / (eta + 1.0)
            if rand < 0.5:
                xy = 1.0 - delta1
                val = 2.0 * rand + (1.0 - 2.0 * rand) * pow(xy, (eta + 1.0))
                deltaq = pow(val, mut_pow) - 1.0
            else:
                xy = 1.0 - delta2
                val = 2.0 * (1.0 - rand) + 2.0 * (rand - 0.5) * pow(xy, (eta + 1.0))
                deltaq = 1.0 - pow(val, mut_pow)
            x = x + deltaq * (up - low)
            x = min(max(x, low), up)
            individual[i] = x
    return individual,

def evolve2(pop_size=100, ngen=50):
    pop = toolbox.population(n=pop_size)
    fitnesses = list(map(toolbox.evaluate, pop))
    for ind, fit in zip(pop, fitnesses):
        ind.fitness.values = fit

    for gen in range(ngen):
        offspring = toolbox.select(pop, len(pop))
        offspring = list(map(toolbox.clone, offspring))

        for child1, child2 in zip(offspring[::2], offspring[1::2]):
            if random.random() < CXPB:
                sbx_crossover(child1, child2, eta=MU)
                del child1.fitness.values
                del child2.fitness.values

        for mutant in offspring:
            if random.random() < MUTPB:
                polynomial_mutation(mutant, eta=ETA)
                del mutant.fitness.values

        invalid_ind = [ind for ind in offspring if not ind.fitness.valid]
        fitnesses = map(toolbox.evaluate, invalid_ind)
        for ind, fit in zip(invalid_ind, fitnesses):
            ind.fitness.values = fit

        pop[:] = offspring

    top = tools.selBest(pop, k=1)[0]
    top_weights = np.array(top) / sum(top)
    return top_weights

# Example usage
if __name__ == "__main__":
    best_weights = evolve2(pop_size=100, ngen=50)
    print("Optimal Portfolio Weights:", best_weights)
